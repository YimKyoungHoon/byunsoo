/* 
싹다 어느정도는 외워놔야되는 듯

변수란? 프로그래밍 언어에서 데이터를 관리하기 위한 개념
인간의 논리 해석 과정처럼 컴퓨터도 이에 해당하는 과정이 있습니다
따라서 자바스크립트도 코드를 평가하려면 리터럴, 연산자라는 기호의 의미와
표현식의 해석이 가능해야 cpu에서 연산하고 메모리를 통해서 데이터를 기억하고 해석할 수 잇는 것
js에서 어떤 식이나 값이 생성되면 메모리에 저장하는데,
각 메모리는 고유 메모리 주소를 가지며, 값은 2진수로 저장됨

따라서 변수란?
하나의 값을 저장하기 위해서 확보한 메모리 공간자체 혹은 그 메모리 공간의 이름이라고 할 수 잇다

변수는 변수이름과 변수값으로 이루어져 잇으며,
변수이름을 식별자라고도 부릅니다.
즉 변수 이름, 식별자는 값을 기억하는 것이 아니라
메모리 주소를 기억하는 것
변수의 식별자 이름을 붙이는 것은 선언에 의해 자바스크립트에게 알리는 것

변수 선언 과정: 변수를 사용하기 위해서는 선연, 즉 생성해야합니다.
변수선언에는 var, let, const라는 방법이 존재합니다.
변수선언의 과정
1. 선언단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수존재를 알림
2. 초기화단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 underfined를 할당하여 초기화
이런 과정을 거친 변수가 선언되면, 변수이름, 식별자는
실행 컨텐스트라는 자바스크립트 엔진이 코드를 평가하고 실행하기 위한 관리영역에 등록되어 관리됩니다.
실행 컨텍스트: 단순하게 코드의 실행 순서, 범위등을 관리하며
실행중 변수나 함수의 식별자들을 해석하는 도움을 주는 도우미

변수가 중복되면 마지막에 코딩한 값이 덮어써져서 재할당이 일어난다
var로 선언하는 변수는 중복선언을 허용합니다.

변수를 사용할려면 변수의 이름을 부르면 변수를 사용할 수 잇습니다.
이것을 변수를 사용한다 혹은 변수를 참조한다고 표현합니다.

변수선언과 호이스팅
호이스팅이란 변수선언이 스코프의 선두로 끌어올려진 것처럼 동작하는
자바스트립트의 고유 특징입니다.
변수의 선언이 소스코드의 한줄씩 순차적으로 실행되는 시점,
즉 런타임이 아니라 그 이전 단계에서 먼저 실행되는데,
자바스크립트 엔진은 실행을 위한 준비단계인 소스 코드 평가의 과정에서
변수선언을 포함한 모든 선언문을 소스코드에서 모두 찾아서 먼저 실행함
따라서 문서 처음 단계에서 문서안의 모든 선언문을 이미 알고 시작합니다.
그리고 소스코드 평가가 끝나면 한줄씩 순차적으로 실행하는 과정을 거치는데
이때 일어나는 이미 알고 시작하는 현상을 호이스팅이라고 하는 것

변수의 스코프: 변수가 영향을 미치는 범위

1. 전역변수: js최상단 즉 코드의 가작 바깥영역에서
선언된({}코드블록 안에서 선언되지 않은) 변수로
js 전체에 걸쳐서 영향을 미치는 변수

특징: 따라서 전역변수는 코드 어디서든지 참조하고 할당할 수 잇는 변수이기 때문에
1) 암묵적 결합: 즉 모든 코드가 전역변수를 참조하고 변경할 수 잇음
-> 변수의 스코프는 클수록 가독성은 나빠지고 위험성도 높아진다
2)긴 생명주기 : 전역변수는 해당 문서가 유효하는 한 생존하며, 따라서 메모리 누수가 크다
3) 네임스페이스 오염: 네임스페이스는 변수이름들을 관리하는 자바스크립트 내부의 공간
자바스트립트는 파일을 분리하더라도 같은 html에 연결되어 있으면
하나의 전역 스코프를 공유하기 때문에 두 분리된 파일의 전역변수를 공유하게 됩니다.
이유는 전역변수나 젼역함수등은 같은 스코프에 존재하기 때문

2. 지역변수: 함수 안에 코드블록안에 선언된 변수로 해당 함수 코드불록 안에서 선언되고 사용됩니다.
지역 변수는 자신의 지역스코프와 하위 지역 스코프에서만 유효하고
var로 선언된 변수는 오직 함수의 코드블록만 지역변수로 인정된다

블록레벨 스코프 : 대부분의 프로그래밍언어는 {} 코드블록이 지역스코프를 만드는데 이것을 블록레벨 스코프라고 한다

함수레벨 스코프 : var키워드로 선언된 변수는 오직 함수의 코드블록만 지역스코프로 인정하는데 
이런 자바스크립트의 특징을 함수레벨 스코프라고 한다

1. 동적 스코프: 즉 호출을 어느 곳에서 하였는지에 따라서 
동적으로 상위 스코프가 변경되는 방식을 동적 스코프라고 한다.

2. 정적 스코프: 다른 말로 렉시컬 스코프
자바스크립트는 이방법으로 상위 스코프를 정하며
정의되는 지점에서의 상의 스코프가 고정되는 방식입니다
-> 이에 따라서 자바스크립트는 함수를 어느 곳에 만들든지 상관이 없음

==변수의 생명주기
변수는 선언에 의해서 생성되고 할당에 의해서 값을 가집니다.
그리고 이후에 데이터타입에 따라서 소멸되는 시간이 있는데 
이것을 변수의 생명주기라고 합니다.

변수의 생명주기가 없다면 변수는 계속해서 메모리공간을 차지하게 됨
결론적으로 변수의 생명주기는 변수의 스코프와 관련있으며
스코프가 끝나는 지점이 소멸, 마갑합니다.

==변수 이름의 규칙
1. 숫자로 시작할 수 없다
2. 특수문자는 사용불가 (단 '$', '_' 사용가능)
3. '-' 사용불가능함
4. 예약어 모두안됨 (예약어란 자바스크립트가 사용하는 단어)
5. 대소문자는 구분되어야하고 서로다른 변수가 된다
6. 한글변수 가능하지만 피하는 게 좋다
+ 변수끼리 연산도 가능함

=== 네이밍 컨벤션 (표기법)
user + details
카멜 - 두 단어가 합쳐진 네이밍에서 표기를 중간에 대문자를 사용해서 결합하는 방법
userdetails
스네이크 - 두 단더가 합쳐진 네이밍에서 표기를 _로 이어주는 방법
user_details
파스칼 - 두 단어가 합쳐질 떄 단어의 맨앞글자만 대문자로 사용해서 
이어주는 방법 나머지는 소문자를 사용
UserDetails
헝가리언 - 데이터 타입을 변수 이름 앞에 붙여서 표기하는 방식
strUsedetails

---- 변수선언방법의 종류
1. var
es5 까지의 방법이며 여러가지 문제점이 있다
문제점
1) 변수 중복선언을 허용한다
코드를 작성하면서 변수값이 변경되는 부작용이 비일비재하게 발생한다
2) 함수레벨 스코프
var로 선언하면 함수코드블록만 지역변수로 인식되고 나머지는 전역변수로 인식하기 때문에
지역 변수의 할당이 어려워진다.
3) 호이스팅

2. let
es6 이후 var의 문제점을 개선한 방법입니다.
해결 방안
1) 변수 중복선언 금지
2) 블록레벨 스코프
var abcd = 1;

if (true) {
    var abcd = 10
}
console.log(abcd); //var를 썼을 떄는 10이 let을 쓰면 1이 출력된다 
3) 호이스팅문제 해결(된 것처럼 보임)
let으로 변수를 선언할 경우 선언과 초기화 단계 사이에
"일시적 사각지대"를 설정하여 변수 선언을 초기화 전에 참조할 수 없게 함
// console.log(aaa); // 레퍼런스 애러 일어남
let aaa;
console.log(aaa); //언디파인드가 출력됨
출력된다는 것은 해당 aaa의 존재를 알고 잇다는 뜻으로
호이스팅이 일어났다고 볼 수 잇음
즉, 호이스팅이 없엇다면 aaa의 존재를 
aaa = 333;
console.log(aaa);

let abc = 1;
{
    console.log(abc); // 레퍼런스 애러가 발생
    애러의 발생에 따라서 알수 잇는 것은
    밑에 2라는 값의 변수가 호이스팅이 되고 잇다는 뜻이다
    호이스팅이 없다면 전역젼수 abc인 1의 값이 정상적으로 찍힐 것
    let abc = 2
}

3. const
변수 - 변하는 수
상수 -  변하지 않는 값
const는 상수를 지정하는 방법으로 정해져 있지만
반드시 상수지정에만 사용하는 것은 아닙니다

상수지정 방법 - 상수의 이름을 모두 대문자로 선언한다
const ROUNDNUMBER = 3.14;

let과 거의 동일하며 다른 부분만 살펴본다면
const는 반드시 선언과 동시에 초기화 작업을 하여야 문법애러가 발생하지 않습니다
상수로 취급되기 떄문에 변수의 재할당이 불가능하지만
이후로 배울 데이터타입에 따라서 변수처럼 재할당이 가능합니다.

주의) const키워드는 재할당을 방지할 뿐 불변성을 담보하는 것은 아님



*/

let aaa = 33; //let으로 변수 선언rhk 동시에 초기화하여 값을 넣은 것
console.log(aaa);
aaa = 44; //기존변수에 값을 덮어쓰는 재할당이 일어난 것
console.log(aaa);

var abcd = 1;

if (true) {
    var abcd = 10
}
var i = 10;
for(var i = 0; i < 5; i++) {
    console.log(i);
}
console.log(i);
var f = 10;
function abc() {
    var f = 34;
    console.log(f);
}

var Ood = "안녕";

var a = 3;
var b = 7;
var result = a + b;
console.log(result);

var day;
console.log(day);

day = 30
console.log(day);

var student;
student = "학생";
console.log(student);
var student = "학생";
console.log(student);

function abc() {
    var sum = 30;
}

console.log(stop);
var stop = "스톱";

// console.log(aaa); // 레퍼런스 애러 일어남
// let aaa;
// console.log(aaa);
// aaa = 333;
// console.log(aaa);

// let abc = 1;
// {
//     console.log(abc);
//     let abc = 2
// }


console.log(test);

var x = 1;
function and() {
    var x = 10;
    or();
}

function or() {
    console.log(x);
}

and();
or();